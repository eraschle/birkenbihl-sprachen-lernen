"""Integration tests for translation editing workflows.

End-to-end tests covering the full workflow of:
1. Creating translations
2. Editing natural translations with provider suggestions
3. Manually editing word-by-word alignments
4. Deleting translations

These tests use real storage and provider implementations.
"""

from pathlib import Path

import pytest

from birkenbihl.models.settings import ProviderConfig
from birkenbihl.models.translation import WordAlignment
from birkenbihl.providers.pydantic_ai_translator import PydanticAITranslator
from birkenbihl.services.language_service import get_language_by
from birkenbihl.services.translation_service import TranslationService
from birkenbihl.storage.sqlite_storage import SqliteStorageProvider


@pytest.fixture
def storage_provider(tmp_path: Path) -> SqliteStorageProvider:
    """Create temporary SQLite storage for integration tests."""
    db_path = tmp_path / "test_translations.db"
    return SqliteStorageProvider(str(db_path))


@pytest.fixture
def translation_service_with_storage(
    openai_provider_config: ProviderConfig, storage_provider: SqliteStorageProvider
) -> TranslationService:
    """Create TranslationService with real storage and OpenAI provider."""
    translator = PydanticAITranslator(openai_provider_config)
    return TranslationService(translator, storage_provider)


@pytest.mark.integration
@pytest.mark.slow
class TestFullWorkflowEditNaturalTranslation:
    """Integration test for editing natural translation workflow."""

    def test_full_workflow_edit_natural_translation(
        self, translation_service_with_storage: TranslationService, openai_provider_config: ProviderConfig
    ):
        """Test complete workflow: create → suggest → update natural → verify alignment regenerated → verify saved.

        Workflow:
        1. Create a translation
        2. Generate alternative suggestions for a sentence
        3. Update natural translation with one of the alternatives
        4. Verify alignment was regenerated
        5. Verify changes were saved to storage
        """
        # Step 1: Create translation
        original_text = "Yo te extrañaré"
        translation = translation_service_with_storage.translate_and_save(
            original_text, get_language_by("es"), get_language_by("de"), "Test Translation"
        )

        assert translation is not None
        assert len(translation.sentences) == 1
        original_sentence = translation.sentences[0]
        original_natural = original_sentence.natural_translation

        # Step 2: Generate suggestions
        suggestions = translation_service_with_storage.get_sentence_suggestions(
            translation.uuid, original_sentence.uuid, openai_provider_config, count=3
        )

        assert len(suggestions) == 3
        assert all(isinstance(s, str) for s in suggestions)
        assert all(len(s.strip()) > 0 for s in suggestions)

        # Step 3: Update natural translation with first suggestion (that's different)
        # Find a suggestion different from original
        new_natural = None
        for suggestion in suggestions:
            if suggestion.strip().rstrip(".") != original_natural.strip().rstrip("."):
                new_natural = suggestion
                break

        # If all suggestions are identical to original, use first one anyway
        if new_natural is None:
            new_natural = suggestions[0]

        updated_translation = translation_service_with_storage.update_sentence_natural(
            translation.uuid, original_sentence.uuid, new_natural, openai_provider_config
        )

        # Step 4: Verify alignment was regenerated
        updated_sentence = updated_translation.sentences[0]
        assert updated_sentence.natural_translation == new_natural
        assert len(updated_sentence.word_alignments) > 0  # Should have new alignments
        # If new_natural is different, alignments should differ (but not guaranteed due to AI variability)
        # So we just verify alignments were regenerated by checking they exist

        # Verify all words from new natural translation are in alignments
        from birkenbihl.models.validation import validate_alignment_complete

        is_valid, error = validate_alignment_complete(new_natural, updated_sentence.word_alignments)
        assert is_valid, f"Regenerated alignment is invalid: {error}"

        # Step 5: Verify changes were saved to storage
        retrieved_translation = translation_service_with_storage.get_translation(translation.uuid)
        assert retrieved_translation is not None
        assert retrieved_translation.sentences[0].natural_translation == new_natural
        assert retrieved_translation.sentences[0].word_alignments == updated_sentence.word_alignments
        assert retrieved_translation.updated_at > translation.updated_at


@pytest.mark.integration
@pytest.mark.slow
class TestFullWorkflowEditAlignmentManually:
    """Integration test for manually editing word-by-word alignment workflow."""

    def test_full_workflow_edit_alignment_manually(self, translation_service_with_storage: TranslationService):
        """Test complete workflow: create → create manual alignments → validate → update → verify saved.

        Workflow:
        1. Create a translation
        2. Manually create new word-by-word alignments
        3. Validate alignments
        4. Update sentence with new alignments
        5. Verify changes were saved to storage
        """
        # Step 1: Create translation
        original_text = "Hello world"
        translation = translation_service_with_storage.translate_and_save(
            original_text, get_language_by("en"), get_language_by("de"), "Manual Edit Test"
        )

        assert translation is not None
        assert len(translation.sentences) == 1
        original_sentence = translation.sentences[0]
        natural_translation = original_sentence.natural_translation  # e.g., "Hallo Welt"

        # Step 2: Manually create new alignments
        # Parse the natural translation to create proper alignments
        words = natural_translation.split()
        if len(words) >= 2:
            new_alignments = [
                WordAlignment(source_word="Hello", target_word=words[0], position=0),
                WordAlignment(source_word="world", target_word=words[1], position=1),
            ]
        else:
            # Fallback if natural translation is single word or hyphenated
            new_alignments = [
                WordAlignment(source_word="Hello", target_word=natural_translation.split()[0], position=0),
                WordAlignment(source_word="world", target_word="world", position=1),
            ]

        # Step 3: Validate alignments
        from birkenbihl.models.validation import validate_alignment_complete

        is_valid, error = validate_alignment_complete(natural_translation, new_alignments)
        assert is_valid, f"Manual alignments are invalid: {error}"

        # Step 4: Update sentence with new alignments
        updated_translation = translation_service_with_storage.update_sentence_alignment(
            translation.uuid, original_sentence.uuid, new_alignments
        )

        # Verify update succeeded
        updated_sentence = updated_translation.sentences[0]
        assert updated_sentence.word_alignments == new_alignments
        assert updated_translation.updated_at > translation.updated_at

        # Step 5: Verify changes were saved to storage
        retrieved_translation = translation_service_with_storage.get_translation(translation.uuid)
        assert retrieved_translation is not None
        assert retrieved_translation.sentences[0].word_alignments == new_alignments


@pytest.mark.integration
@pytest.mark.slow
class TestDeleteTranslation:
    """Integration test for translation deletion workflow."""

    def test_delete_translation(self, translation_service_with_storage: TranslationService):
        """Test complete workflow: create → delete → verify not in storage.

        Workflow:
        1. Create a translation
        2. Delete translation via service
        3. Verify translation no longer in storage
        """
        # Step 1: Create translation
        original_text = "Test deletion"
        translation = translation_service_with_storage.translate_and_save(
            original_text, get_language_by("en"), get_language_by("de"), "To Be Deleted"
        )

        assert translation is not None
        translation_id = translation.uuid

        # Verify translation exists in storage
        retrieved = translation_service_with_storage.get_translation(translation_id)
        assert retrieved is not None

        # Step 2: Delete translation
        deleted = translation_service_with_storage.delete_translation(translation_id)
        assert deleted is True

        # Step 3: Verify not in storage
        retrieved_after_delete = translation_service_with_storage.get_translation(translation_id)
        assert retrieved_after_delete is None

        # Verify it's not in list_all either
        all_translations = translation_service_with_storage.list_all_translations()
        assert translation_id not in [t.uuid for t in all_translations]


@pytest.mark.integration
@pytest.mark.slow
class TestMultipleEditsWorkflow:
    """Integration test for multiple sequential edits."""

    def test_multiple_edits_preserve_data_integrity(
        self, translation_service_with_storage: TranslationService, openai_provider_config: ProviderConfig
    ):
        """Test that multiple sequential edits maintain data integrity.

        Workflow:
        1. Create translation
        2. Edit natural translation
        3. Edit alignment manually
        4. Verify all changes persisted correctly
        """
        # Step 1: Create translation
        original_text = "Yo te extrañaré"
        translation = translation_service_with_storage.translate_and_save(
            original_text, get_language_by("es"), get_language_by("de"), "Multiple Edits Test"
        )

        sentence_uuid = translation.sentences[0].uuid
        original_updated_at = translation.updated_at

        # Step 2: Edit natural translation
        suggestions = translation_service_with_storage.get_sentence_suggestions(
            translation.uuid, sentence_uuid, openai_provider_config, count=3
        )
        new_natural = suggestions[0]

        translation = translation_service_with_storage.update_sentence_natural(
            translation.uuid, sentence_uuid, new_natural, openai_provider_config
        )

        assert translation.sentences[0].natural_translation == new_natural
        assert translation.updated_at > original_updated_at
        after_natural_update = translation.updated_at

        # Step 3: Edit alignment manually (add extra mapping)
        current_alignments = translation.sentences[0].word_alignments
        # Just verify we can update with current alignments (no-op change)
        translation = translation_service_with_storage.update_sentence_alignment(
            translation.uuid, sentence_uuid, current_alignments
        )

        assert translation.updated_at >= after_natural_update

        # Step 4: Verify final state
        final_translation = translation_service_with_storage.get_translation(translation.uuid)
        assert final_translation is not None
        assert final_translation.sentences[0].natural_translation == new_natural
        assert final_translation.sentences[0].word_alignments == current_alignments
